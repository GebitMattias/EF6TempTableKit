using EF6TempTableKit.DbContext;
using System;
using System.Collections.Generic;
using System.Data.Entity.Core.Objects;
using System.Linq;
using System.Text;
using EF6TempTableKit.SqlCommands;

namespace EF6TempTableKit.Utilities
{
    /// <summary>
    /// Queries attached on a context are stored in a queue(FIFO) data structure. Why? Because last attached query typically has dependencies on previously attached queries.
    /// </summary>
    internal sealed class SqlFromTempTableDependenciesBuilder
    {
        private readonly Version _assemblyVersion;
        private readonly string _generatedByEf6TempTableKitStartMsg;
        private readonly string _generatedByEf6TempTableKitEndMsg;
        private readonly IDictionary<string, HashSet<string>> _tempOnTempDependencies;
        private readonly Queue<KeyValuePair<string, Query>> _tempSqlQueriesList;
        private HashSet<string> _alreadyAttachedTempTableQuery;

        internal SqlFromTempTableDependenciesBuilder(TempTableContainer tempTableContainer)
        {
            _tempOnTempDependencies = tempTableContainer.TempOnTempDependencies;
            _tempSqlQueriesList = tempTableContainer.TempSqlQueriesList;
            _alreadyAttachedTempTableQuery = new HashSet<string>();

            _assemblyVersion = typeof(EF6TempTableKitQueryInterceptor).Assembly.GetName().Version;
            _generatedByEf6TempTableKitStartMsg = $"/* Generated by EF6TempTableKit {_assemblyVersion} - START */";
            _generatedByEf6TempTableKitEndMsg = $"/* Generated by EF6TempTableKit {_assemblyVersion} - END*/";
        }

        /// <summary>
        /// Builds SQL for the Temp-Table insert
        /// </summary>
        /// <param name="interceptedCommandText">Original command text that got intercepted</param>
        /// <param name="additionalParameters">Additional parameters that need to be added</param>
        /// <returns>Command text to insert the temp tables</returns>
        public string BuildSqlForTempTables(string interceptedCommandText, out IEnumerable<ObjectParameter> additionalParameters)
        {
            var sqlStringBuilder = new StringBuilder();

            // New Index to prepend the parameters and keep them unique
            var parameterIndex = 0;
            var newParameters = new List<ObjectParameter>();
            additionalParameters = newParameters;

            foreach (var tableSqlQuery in _tempSqlQueriesList)
            {
                var tempTableName = tableSqlQuery.Key;
                var tempTableSql = tableSqlQuery.Value;

                var tempTableNameWithBrackets = $"[{tempTableName}]";
                var isTempTableAlreadyAttached = _alreadyAttachedTempTableQuery.Contains(tempTableName);

                if ((isTempTableAlreadyAttached && !tempTableSql.IsDataAppend) || !interceptedCommandText.Contains(tempTableNameWithBrackets)) continue;
                var hasTempTableDependencies = this._tempOnTempDependencies.ContainsKey(tempTableName);

                
                ParameterSqlQuery sql;
                if (hasTempTableDependencies)
                {
                    foreach (var tempTableDependency in this._tempOnTempDependencies[tempTableName])
                    {
                        foreach (var query in this._tempSqlQueriesList.Where(x => x.Key == tempTableDependency))
                        {
                            sql = ParameterSqlQuery.ToAdjustedParameters(tempTableSql.SqlQuery, tempTableSql.Parameters, parameterIndex);
                            newParameters.AddRange(sql.Parameters);
                            parameterIndex++;
                            this.AppendIfNotAlreadyAttached(sqlStringBuilder, sql.Sql, tempTableDependency, query.Value.IsDataAppend);
                        }
                    }
                }

                sql = ParameterSqlQuery.ToAdjustedParameters(tempTableSql.SqlQuery, tempTableSql.Parameters, parameterIndex);
                newParameters.AddRange(sql.Parameters);
                parameterIndex++;
                this.AppendIfNotAlreadyAttached(sqlStringBuilder, sql.Sql, tempTableName, tempTableSql.IsDataAppend);
            }

            return sqlStringBuilder.ToString();
        }

        private void AppendIfNotAlreadyAttached(StringBuilder sqlStringBuilder, string sqlStringToAppend, string tempTableName, bool isDataAppend)
        {
            var isTempTableAlreadyAttached = _alreadyAttachedTempTableQuery.Contains(tempTableName);
            if (!isTempTableAlreadyAttached || isDataAppend)
            {
                var selectCommandTextFormat = "\n{0}\n{1}\n{2}\n";
                sqlStringBuilder.AppendFormat(selectCommandTextFormat, _generatedByEf6TempTableKitStartMsg, sqlStringToAppend, _generatedByEf6TempTableKitEndMsg);
                _alreadyAttachedTempTableQuery.Add(tempTableName);
            }
        }
    }
}
